schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "accounts"
"""
type accounts {
  balance: bigint!
  created_at: timestamptz!
  deleted_at: timestamptz!
  email: String!
  ext_id: String!
  id: Int!
  name: String!
  picture: String
  pin: String!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): [purchases!]!

  """An aggregate relationship"""
  purchases_aggregate(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): purchases_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "accounts"
"""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

"""
aggregate fields of "accounts"
"""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"""aggregate avg on columns"""
type accounts_avg_fields {
  balance: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  balance: bigint_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  ext_id: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  picture: String_comparison_exp
  pin: String_comparison_exp
  purchases: purchases_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "accounts"
"""
enum accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for incrementing numeric columns in table "accounts"
"""
input accounts_inc_input {
  balance: bigint
  id: Int
}

"""
input type for inserting data into table "accounts"
"""
input accounts_insert_input {
  balance: bigint
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  ext_id: String
  id: Int
  name: String
  picture: String
  pin: String
  purchases: purchases_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type accounts_max_fields {
  balance: bigint
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  ext_id: String
  id: Int
  name: String
  picture: String
  pin: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type accounts_min_fields {
  balance: bigint
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  ext_id: String
  id: Int
  name: String
  picture: String
  pin: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "accounts"
"""
type accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts!]!
}

"""
input type for inserting object relation for remote table "accounts"
"""
input accounts_obj_rel_insert_input {
  data: accounts_insert_input!

  """upsert condition"""
  on_conflict: accounts_on_conflict
}

"""
on_conflict condition type for table "accounts"
"""
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]! = []
  where: accounts_bool_exp
}

"""Ordering options when selecting data from "accounts"."""
input accounts_order_by {
  balance: order_by
  created_at: order_by
  deleted_at: order_by
  email: order_by
  ext_id: order_by
  id: order_by
  name: order_by
  picture: order_by
  pin: order_by
  purchases_aggregate: purchases_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: accounts"""
input accounts_pk_columns_input {
  id: Int!
}

"""
select columns of table "accounts"
"""
enum accounts_select_column {
  """column name"""
  balance

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  ext_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  picture

  """column name"""
  pin

  """column name"""
  updated_at
}

"""
input type for updating data in table "accounts"
"""
input accounts_set_input {
  balance: bigint
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  ext_id: String
  id: Int
  name: String
  picture: String
  pin: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type accounts_stddev_fields {
  balance: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type accounts_stddev_pop_fields {
  balance: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type accounts_stddev_samp_fields {
  balance: Float
  id: Float
}

"""
Streaming cursor of the table "accounts"
"""
input accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_stream_cursor_value_input {
  balance: bigint
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  ext_id: String
  id: Int
  name: String
  picture: String
  pin: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type accounts_sum_fields {
  balance: bigint
  id: Int
}

"""
update columns of table "accounts"
"""
enum accounts_update_column {
  """column name"""
  balance

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  ext_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  picture

  """column name"""
  pin

  """column name"""
  updated_at
}

input accounts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: accounts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_set_input
  where: accounts_bool_exp!
}

"""aggregate var_pop on columns"""
type accounts_var_pop_fields {
  balance: Float
  id: Float
}

"""aggregate var_samp on columns"""
type accounts_var_samp_fields {
  balance: Float
  id: Float
}

"""aggregate variance on columns"""
type accounts_variance_fields {
  balance: Float
  id: Float
}

type Address {
  address: String
  city: String
  state: String
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

type Capsule {
  dragon: Dragon
  id: ID
  landings: Int
  missions: [CapsuleMission]
  original_launch: Date
  reuse_count: Int
  status: String
  type: String
}

type CapsuleMission {
  flight: Int
  name: String
}

input CapsulesFind {
  id: ID
  landings: Int
  mission: String
  original_launch: Date
  reuse_count: Int
  status: String
  type: String
}

type Core {
  asds_attempts: Int
  asds_landings: Int
  block: Int
  id: ID
  missions: [CapsuleMission]
  original_launch: Date
  reuse_count: Int
  rtls_attempts: Int
  rtls_landings: Int
  status: String
  water_landing: Boolean
}

input CoresFind {
  asds_attempts: Int
  asds_landings: Int
  block: Int
  id: String
  missions: String
  original_launch: Date
  reuse_count: Int
  rtls_attempts: Int
  rtls_landings: Int
  status: String
  water_landing: Boolean
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar Date

type Distance {
  feet: Float
  meters: Float
}

type Dragon {
  active: Boolean
  crew_capacity: Int
  description: String
  diameter: Distance
  dry_mass_kg: Int
  dry_mass_lb: Int
  first_flight: String
  heat_shield: DragonHeatShield
  height_w_trunk: Distance
  id: ID
  launch_payload_mass: Mass
  launch_payload_vol: Volume
  name: String
  orbit_duration_yr: Int
  pressurized_capsule: DragonPressurizedCapsule
  return_payload_mass: Mass
  return_payload_vol: Volume
  sidewall_angle_deg: Float
  thrusters: [DragonThrust]
  trunk: DragonTrunk
  type: String
  wikipedia: String
}

type DragonHeatShield {
  dev_partner: String
  material: String
  size_meters: Float
  temp_degrees: Int
}

type DragonPressurizedCapsule {
  payload_volume: Volume
}

type DragonThrust {
  amount: Int
  fuel_1: String
  fuel_2: String
  pods: Int
  thrust: Force
  type: String
}

type DragonTrunk {
  cargo: DragonTrunkCargo
  trunk_volume: Volume
}

type DragonTrunkCargo {
  solar_array: Int
  unpressurized_cargo: Boolean
}

type Force {
  kN: Float
  lbf: Float
}

type HistoriesResult {
  data: [History]
  result: Result
}

type History {
  details: String
  event_date_unix: Date
  event_date_utc: Date
  flight: Launch
  id: ID
  links: Link
  title: String
}

input HistoryFind {
  end: Date
  flight_number: Int
  id: ID
  start: Date
}

type Info {
  ceo: String
  coo: String
  cto: String
  cto_propulsion: String
  employees: Int
  founded: Int
  founder: String
  headquarters: Address
  launch_sites: Int
  links: InfoLinks
  name: String
  summary: String
  test_sites: Int
  valuation: Float
  vehicles: Int
}

type InfoLinks {
  elon_twitter: String
  flickr: String
  twitter: String
  website: String
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type Landpad {
  attempted_landings: String
  details: String
  full_name: String
  id: ID
  landing_type: String
  location: Location
  status: String
  successful_landings: String
  wikipedia: String
}

type Launch {
  details: String
  id: ID
  is_tentative: Boolean
  launch_date_local: Date
  launch_date_unix: Date
  launch_date_utc: Date
  launch_site: LaunchSite
  launch_success: Boolean
  launch_year: String
  links: LaunchLinks
  mission_id: [String]
  mission_name: String
  rocket: LaunchRocket
  ships: [Ship]
  static_fire_date_unix: Date
  static_fire_date_utc: Date
  telemetry: LaunchTelemetry
  tentative_max_precision: String
  upcoming: Boolean
}

type LaunchesPastResult {
  data: [Launch]
  result: Result
}

input LaunchFind {
  apoapsis_km: Float
  block: Int
  cap_serial: String
  capsule_reuse: String
  core_flight: Int
  core_reuse: String
  core_serial: String
  customer: String
  eccentricity: Float
  end: Date
  epoch: Date
  fairings_recovered: String
  fairings_recovery_attempt: String
  fairings_reuse: String
  fairings_reused: String
  fairings_ship: String
  gridfins: String
  id: ID
  inclination_deg: Float
  land_success: String
  landing_intent: String
  landing_type: String
  landing_vehicle: String
  launch_date_local: Date
  launch_date_utc: Date
  launch_success: String
  launch_year: String
  legs: String
  lifespan_years: Float
  longitude: Float
  manufacturer: String
  mean_motion: Float
  mission_id: String
  mission_name: String
  nationality: String
  norad_id: Int
  orbit: String
  payload_id: String
  payload_type: String
  periapsis_km: Float
  period_min: Float
  raan: Float
  reference_system: String
  regime: String
  reused: String
  rocket_id: String
  rocket_name: String
  rocket_type: String
  second_stage_block: String
  semi_major_axis_km: Float
  ship: String
  side_core1_reuse: String
  side_core2_reuse: String
  site_id: String
  site_name: String
  site_name_long: String
  start: Date
  tbd: String
  tentative: String
  tentative_max_precision: String
}

type LaunchLinks {
  article_link: String
  flickr_images: [String]
  mission_patch: String
  mission_patch_small: String
  presskit: String
  reddit_campaign: String
  reddit_launch: String
  reddit_media: String
  reddit_recovery: String
  video_link: String
  wikipedia: String
}

type Launchpad {
  attempted_launches: Int
  details: String
  id: ID
  location: Location
  name: String
  status: String
  successful_launches: Int
  vehicles_launched: [Rocket]
  wikipedia: String
}

type LaunchRocket {
  fairings: LaunchRocketFairings
  first_stage: LaunchRocketFirstStage
  rocket: Rocket
  rocket_name: String
  rocket_type: String
  second_stage: LaunchRocketSecondStage
}

type LaunchRocketFairings {
  recovered: Boolean
  recovery_attempt: Boolean
  reused: Boolean
  ship: String
}

type LaunchRocketFirstStage {
  cores: [LaunchRocketFirstStageCore]
}

type LaunchRocketFirstStageCore {
  block: Int
  core: Core
  flight: Int
  gridfins: Boolean
  land_success: Boolean
  landing_intent: Boolean
  landing_type: String
  landing_vehicle: String
  legs: Boolean
  reused: Boolean
}

type LaunchRocketSecondStage {
  block: Int
  payloads: [Payload]
}

type LaunchSite {
  site_id: String
  site_name: String
  site_name_long: String
}

type LaunchTelemetry {
  flight_club: String
}

type Link {
  article: String
  reddit: String
  wikipedia: String
}

type Location {
  latitude: Float
  longitude: Float
  name: String
  region: String
}

type Mass {
  kg: Int
  lb: Int
}

type Mission {
  description: String
  id: ID
  manufacturers: [String]
  name: String
  payloads: [Payload]
  twitter: String
  website: String
  wikipedia: String
}

type MissionResult {
  data: [Mission]
  result: Result
}

input MissionsFind {
  id: ID
  manufacturer: String
  name: String
  payload_id: String
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "accounts"
  """
  delete_accounts(
    """filter the rows which have to be deleted"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  delete single row from the table: "accounts"
  """
  delete_accounts_by_pk(id: Int!): accounts

  """
  delete data from the table: "products"
  """
  delete_products(
    """filter the rows which have to be deleted"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  delete single row from the table: "products"
  """
  delete_products_by_pk(id: Int!): products

  """
  delete data from the table: "purchases"
  """
  delete_purchases(
    """filter the rows which have to be deleted"""
    where: purchases_bool_exp!
  ): purchases_mutation_response

  """
  delete single row from the table: "purchases"
  """
  delete_purchases_by_pk(id: bigint!): purchases

  """
  insert data into the table: "accounts"
  """
  insert_accounts(
    """the rows to be inserted"""
    objects: [accounts_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response

  """
  insert a single row into the table: "accounts"
  """
  insert_accounts_one(
    """the row to be inserted"""
    object: accounts_insert_input!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts

  """
  insert data into the table: "products"
  """
  insert_products(
    """the rows to be inserted"""
    objects: [products_insert_input!]!

    """upsert condition"""
    on_conflict: products_on_conflict
  ): products_mutation_response

  """
  insert a single row into the table: "products"
  """
  insert_products_one(
    """the row to be inserted"""
    object: products_insert_input!

    """upsert condition"""
    on_conflict: products_on_conflict
  ): products

  """
  insert data into the table: "purchases"
  """
  insert_purchases(
    """the rows to be inserted"""
    objects: [purchases_insert_input!]!

    """upsert condition"""
    on_conflict: purchases_on_conflict
  ): purchases_mutation_response

  """
  insert a single row into the table: "purchases"
  """
  insert_purchases_one(
    """the row to be inserted"""
    object: purchases_insert_input!

    """upsert condition"""
    on_conflict: purchases_on_conflict
  ): purchases

  """
  update data of the table: "accounts"
  """
  update_accounts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input

    """filter the rows which have to be updated"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  update single row of the table: "accounts"
  """
  update_accounts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input
    pk_columns: accounts_pk_columns_input!
  ): accounts

  """
  update multiples rows of table: "accounts"
  """
  update_accounts_many(
    """updates to execute, in order"""
    updates: [accounts_updates!]!
  ): [accounts_mutation_response]

  """
  update data of the table: "products"
  """
  update_products(
    """increments the numeric columns with given value of the filtered values"""
    _inc: products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input

    """filter the rows which have to be updated"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  update single row of the table: "products"
  """
  update_products_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input
    pk_columns: products_pk_columns_input!
  ): products

  """
  update multiples rows of table: "products"
  """
  update_products_many(
    """updates to execute, in order"""
    updates: [products_updates!]!
  ): [products_mutation_response]

  """
  update data of the table: "purchases"
  """
  update_purchases(
    """increments the numeric columns with given value of the filtered values"""
    _inc: purchases_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: purchases_set_input

    """filter the rows which have to be updated"""
    where: purchases_bool_exp!
  ): purchases_mutation_response

  """
  update single row of the table: "purchases"
  """
  update_purchases_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: purchases_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: purchases_set_input
    pk_columns: purchases_pk_columns_input!
  ): purchases

  """
  update multiples rows of table: "purchases"
  """
  update_purchases_many(
    """updates to execute, in order"""
    updates: [purchases_updates!]!
  ): [purchases_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type Payload {
  customers: [String]
  id: ID
  manufacturer: String
  nationality: String
  norad_id: [Int]
  orbit: String
  orbit_params: PayloadOrbitParams
  payload_mass_kg: Float
  payload_mass_lbs: Float
  payload_type: String
  reused: Boolean
}

type PayloadOrbitParams {
  apoapsis_km: Float
  arg_of_pericenter: Float
  eccentricity: Float
  epoch: Date
  inclination_deg: Float
  lifespan_years: Float
  longitude: Float
  mean_anomaly: Float
  mean_motion: Float
  periapsis_km: Float
  period_min: Float
  raan: Float
  reference_system: String
  regime: String
  semi_major_axis_km: Float
}

input PayloadsFind {
  apoapsis_km: Float
  customer: String
  eccentricity: Float
  epoch: Date
  inclination_deg: Float
  lifespan_years: Float
  longitude: Float
  manufacturer: String
  mean_motion: Float
  nationality: String
  norad_id: Int
  orbit: String
  payload_id: ID
  payload_type: String
  periapsis_km: Float
  period_min: Float
  raan: Float
  reference_system: String
  regime: String
  reused: Boolean
  semi_major_axis_km: Float
}

"""
columns and relationships of "products"
"""
type products {
  bundle_size: Int!
  created_at: timestamptz!
  deleted_at: timestamptz!
  id: Int!
  name: String!
  picture: String
  price: bigint!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): [purchases!]!

  """An aggregate relationship"""
  purchases_aggregate(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): purchases_aggregate!
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "products"
"""
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

"""
aggregate fields of "products"
"""
type products_aggregate_fields {
  avg: products_avg_fields
  count(columns: [products_select_column!], distinct: Boolean): Int!
  max: products_max_fields
  min: products_min_fields
  stddev: products_stddev_fields
  stddev_pop: products_stddev_pop_fields
  stddev_samp: products_stddev_samp_fields
  sum: products_sum_fields
  var_pop: products_var_pop_fields
  var_samp: products_var_samp_fields
  variance: products_variance_fields
}

"""aggregate avg on columns"""
type products_avg_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""
Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'.
"""
input products_bool_exp {
  _and: [products_bool_exp!]
  _not: products_bool_exp
  _or: [products_bool_exp!]
  bundle_size: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  picture: String_comparison_exp
  price: bigint_comparison_exp
  purchases: purchases_bool_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "products"
"""
enum products_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  products_pkey
}

"""
input type for incrementing numeric columns in table "products"
"""
input products_inc_input {
  bundle_size: Int
  id: Int
  price: bigint
}

"""
input type for inserting data into table "products"
"""
input products_insert_input {
  bundle_size: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: Int
  name: String
  picture: String
  price: bigint
  purchases: purchases_arr_rel_insert_input
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type products_max_fields {
  bundle_size: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: Int
  name: String
  picture: String
  price: bigint
  type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type products_min_fields {
  bundle_size: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: Int
  name: String
  picture: String
  price: bigint
  type: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "products"
"""
type products_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [products!]!
}

"""
input type for inserting object relation for remote table "products"
"""
input products_obj_rel_insert_input {
  data: products_insert_input!

  """upsert condition"""
  on_conflict: products_on_conflict
}

"""
on_conflict condition type for table "products"
"""
input products_on_conflict {
  constraint: products_constraint!
  update_columns: [products_update_column!]! = []
  where: products_bool_exp
}

"""Ordering options when selecting data from "products"."""
input products_order_by {
  bundle_size: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  picture: order_by
  price: order_by
  purchases_aggregate: purchases_aggregate_order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: products"""
input products_pk_columns_input {
  id: Int!
}

"""
select columns of table "products"
"""
enum products_select_column {
  """column name"""
  bundle_size

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  picture

  """column name"""
  price

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "products"
"""
input products_set_input {
  bundle_size: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: Int
  name: String
  picture: String
  price: bigint
  type: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type products_stddev_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""aggregate stddev_pop on columns"""
type products_stddev_pop_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""aggregate stddev_samp on columns"""
type products_stddev_samp_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""
Streaming cursor of the table "products"
"""
input products_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: products_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input products_stream_cursor_value_input {
  bundle_size: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: Int
  name: String
  picture: String
  price: bigint
  type: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type products_sum_fields {
  bundle_size: Int
  id: Int
  price: bigint
}

"""
update columns of table "products"
"""
enum products_update_column {
  """column name"""
  bundle_size

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  picture

  """column name"""
  price

  """column name"""
  type

  """column name"""
  updated_at
}

input products_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: products_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: products_set_input
  where: products_bool_exp!
}

"""aggregate var_pop on columns"""
type products_var_pop_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""aggregate var_samp on columns"""
type products_var_samp_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""aggregate variance on columns"""
type products_variance_fields {
  bundle_size: Float
  id: Float
  price: Float
}

"""
columns and relationships of "purchases"
"""
type purchases {
  """An object relationship"""
  account: accounts!
  account_id: Int!
  created_at: timestamptz!
  deleted_at: timestamptz!
  id: bigint!
  paid_price: bigint!

  """An object relationship"""
  product: products!
  product_id: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "purchases"
"""
type purchases_aggregate {
  aggregate: purchases_aggregate_fields
  nodes: [purchases!]!
}

"""
aggregate fields of "purchases"
"""
type purchases_aggregate_fields {
  avg: purchases_avg_fields
  count(columns: [purchases_select_column!], distinct: Boolean): Int!
  max: purchases_max_fields
  min: purchases_min_fields
  stddev: purchases_stddev_fields
  stddev_pop: purchases_stddev_pop_fields
  stddev_samp: purchases_stddev_samp_fields
  sum: purchases_sum_fields
  var_pop: purchases_var_pop_fields
  var_samp: purchases_var_samp_fields
  variance: purchases_variance_fields
}

"""
order by aggregate values of table "purchases"
"""
input purchases_aggregate_order_by {
  avg: purchases_avg_order_by
  count: order_by
  max: purchases_max_order_by
  min: purchases_min_order_by
  stddev: purchases_stddev_order_by
  stddev_pop: purchases_stddev_pop_order_by
  stddev_samp: purchases_stddev_samp_order_by
  sum: purchases_sum_order_by
  var_pop: purchases_var_pop_order_by
  var_samp: purchases_var_samp_order_by
  variance: purchases_variance_order_by
}

"""
input type for inserting array relation for remote table "purchases"
"""
input purchases_arr_rel_insert_input {
  data: [purchases_insert_input!]!

  """upsert condition"""
  on_conflict: purchases_on_conflict
}

"""aggregate avg on columns"""
type purchases_avg_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by avg() on columns of table "purchases"
"""
input purchases_avg_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "purchases". All fields are combined with a logical 'AND'.
"""
input purchases_bool_exp {
  _and: [purchases_bool_exp!]
  _not: purchases_bool_exp
  _or: [purchases_bool_exp!]
  account: accounts_bool_exp
  account_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  paid_price: bigint_comparison_exp
  product: products_bool_exp
  product_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "purchases"
"""
enum purchases_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  purchases_pkey
}

"""
input type for incrementing numeric columns in table "purchases"
"""
input purchases_inc_input {
  account_id: Int
  id: bigint
  paid_price: bigint
  product_id: Int
}

"""
input type for inserting data into table "purchases"
"""
input purchases_insert_input {
  account: accounts_obj_rel_insert_input
  account_id: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: bigint
  paid_price: bigint
  product: products_obj_rel_insert_input
  product_id: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type purchases_max_fields {
  account_id: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: bigint
  paid_price: bigint
  product_id: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "purchases"
"""
input purchases_max_order_by {
  account_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type purchases_min_fields {
  account_id: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: bigint
  paid_price: bigint
  product_id: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "purchases"
"""
input purchases_min_order_by {
  account_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "purchases"
"""
type purchases_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [purchases!]!
}

"""
on_conflict condition type for table "purchases"
"""
input purchases_on_conflict {
  constraint: purchases_constraint!
  update_columns: [purchases_update_column!]! = []
  where: purchases_bool_exp
}

"""Ordering options when selecting data from "purchases"."""
input purchases_order_by {
  account: accounts_order_by
  account_id: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  paid_price: order_by
  product: products_order_by
  product_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: purchases"""
input purchases_pk_columns_input {
  id: bigint!
}

"""
select columns of table "purchases"
"""
enum purchases_select_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  paid_price

  """column name"""
  product_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "purchases"
"""
input purchases_set_input {
  account_id: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: bigint
  paid_price: bigint
  product_id: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type purchases_stddev_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by stddev() on columns of table "purchases"
"""
input purchases_stddev_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type purchases_stddev_pop_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "purchases"
"""
input purchases_stddev_pop_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type purchases_stddev_samp_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "purchases"
"""
input purchases_stddev_samp_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""
Streaming cursor of the table "purchases"
"""
input purchases_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: purchases_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input purchases_stream_cursor_value_input {
  account_id: Int
  created_at: timestamptz
  deleted_at: timestamptz
  id: bigint
  paid_price: bigint
  product_id: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type purchases_sum_fields {
  account_id: Int
  id: bigint
  paid_price: bigint
  product_id: Int
}

"""
order by sum() on columns of table "purchases"
"""
input purchases_sum_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""
update columns of table "purchases"
"""
enum purchases_update_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  paid_price

  """column name"""
  product_id

  """column name"""
  updated_at
}

input purchases_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: purchases_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: purchases_set_input
  where: purchases_bool_exp!
}

"""aggregate var_pop on columns"""
type purchases_var_pop_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "purchases"
"""
input purchases_var_pop_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type purchases_var_samp_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "purchases"
"""
input purchases_var_samp_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type purchases_variance_fields {
  account_id: Float
  id: Float
  paid_price: Float
  product_id: Float
}

"""
order by variance() on columns of table "purchases"
"""
input purchases_variance_order_by {
  account_id: order_by
  id: order_by
  paid_price: order_by
  product_id: order_by
}

type query_root {
  """
  fetch data from the table: "accounts"
  """
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """
  fetch aggregated fields from the table: "accounts"
  """
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: Int!): accounts
  capsule(id: ID!): Capsule
  capsules(find: CapsulesFind, limit: Int, offset: Int, order: String, sort: String): [Capsule]
  capsulesPast(find: CapsulesFind, limit: Int, offset: Int, order: String, sort: String): [Capsule]
  capsulesUpcoming(find: CapsulesFind, limit: Int, offset: Int, order: String, sort: String): [Capsule]
  company: Info
  core(id: ID!): Core
  cores(find: CoresFind, limit: Int, offset: Int, order: String, sort: String): [Core]
  coresPast(find: CoresFind, limit: Int, offset: Int, order: String, sort: String): [Core]
  coresUpcoming(find: CoresFind, limit: Int, offset: Int, order: String, sort: String): [Core]
  dragon(id: ID!): Dragon
  dragons(limit: Int, offset: Int): [Dragon]
  histories(find: HistoryFind, limit: Int, offset: Int, order: String, sort: String): [History]
  historiesResult(find: HistoryFind, limit: Int, offset: Int, order: String, sort: String): HistoriesResult
  history(id: ID!): History
  landpad(id: ID!): Landpad
  landpads(limit: Int, offset: Int): [Landpad]
  launch(id: ID!): Launch
  launchLatest(offset: Int): Launch
  launchNext(offset: Int): Launch
  launches(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): [Launch]
  launchesPast(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): [Launch]
  launchesPastResult(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): LaunchesPastResult
  launchesUpcoming(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): [Launch]
  launchpad(id: ID!): Launchpad
  launchpads(limit: Int, offset: Int): [Launchpad]
  mission(id: ID!): Mission
  missions(find: MissionsFind, limit: Int, offset: Int): [Mission]
  missionsResult(find: MissionsFind, limit: Int, offset: Int): MissionResult
  payload(id: ID!): Payload
  payloads(find: PayloadsFind, limit: Int, offset: Int, order: String, sort: String): [Payload]

  """
  fetch data from the table: "products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """fetch data from the table: "products" using primary key columns"""
  products_by_pk(id: Int!): products

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): [purchases!]!

  """An aggregate relationship"""
  purchases_aggregate(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): purchases_aggregate!

  """fetch data from the table: "purchases" using primary key columns"""
  purchases_by_pk(id: bigint!): purchases
  roadster: Roadster
  rocket(id: ID!): Rocket
  rockets(limit: Int, offset: Int): [Rocket]
  rocketsResult(limit: Int, offset: Int): RocketsResult
  ship(id: ID!): Ship
  ships(find: ShipsFind, limit: Int, offset: Int, order: String, sort: String): [Ship]
  shipsResult(find: ShipsFind, limit: Int, offset: Int, order: String, sort: String): ShipsResult
}

type Result {
  totalCount: Int
}

type Roadster {
  apoapsis_au: Float
  details: String
  earth_distance_km: Float
  earth_distance_mi: Float
  eccentricity: Float
  epoch_jd: Float
  inclination: Float
  launch_date_unix: Date
  launch_date_utc: Date
  launch_mass_kg: Int
  launch_mass_lbs: Int
  longitude: Float
  mars_distance_km: Float
  mars_distance_mi: Float
  name: String
  norad_id: Int
  orbit_type: Float
  periapsis_arg: Float
  periapsis_au: Float
  period_days: Float
  semi_major_axis_au: Float
  speed_kph: Float
  speed_mph: Float
  wikipedia: String
}

type Rocket {
  active: Boolean
  boosters: Int
  company: String
  cost_per_launch: Int
  country: String
  description: String
  diameter: Distance
  engines: RocketEngines
  first_flight: Date
  first_stage: RocketFirstStage
  height: Distance
  id: ID
  landing_legs: RocketLandingLegs
  mass: Mass
  name: String
  payload_weights: [RocketPayloadWeight]
  second_stage: RocketSecondStage
  stages: Int
  success_rate_pct: Int
  type: String
  wikipedia: String
}

type RocketEngines {
  engine_loss_max: String
  layout: String
  number: Int
  propellant_1: String
  propellant_2: String
  thrust_sea_level: Force
  thrust_to_weight: Float
  thrust_vacuum: Force
  type: String
  version: String
}

type RocketFirstStage {
  burn_time_sec: Int
  engines: Int
  fuel_amount_tons: Float
  reusable: Boolean
  thrust_sea_level: Force
  thrust_vacuum: Force
}

type RocketLandingLegs {
  material: String
  number: Int
}

type RocketPayloadWeight {
  id: String
  kg: Int
  lb: Int
  name: String
}

type RocketSecondStage {
  burn_time_sec: Int
  engines: Int
  fuel_amount_tons: Float
  payloads: RocketSecondStagePayloads
  thrust: Force
}

type RocketSecondStagePayloadCompositeFairing {
  diameter: Distance
  height: Distance
}

type RocketSecondStagePayloads {
  composite_fairing: RocketSecondStagePayloadCompositeFairing
  option_1: String
}

type RocketsResult {
  data: [Rocket]
  result: Result
}

type Ship {
  abs: Int
  active: Boolean
  attempted_landings: Int
  class: Int
  course_deg: Int
  home_port: String
  id: ID
  image: String
  imo: Int
  missions: [ShipMission]
  mmsi: Int
  model: String
  name: String
  position: ShipLocation
  roles: [String]
  speed_kn: Float
  status: String
  successful_landings: Int
  type: String
  url: String
  weight_kg: Int
  weight_lbs: Int
  year_built: Int
}

type ShipLocation {
  latitude: Float
  longitude: Float
}

type ShipMission {
  flight: String
  name: String
}

input ShipsFind {
  abs: Int
  active: Boolean
  attempted_landings: Int
  class: Int
  course_deg: Int
  home_port: String
  id: ID
  imo: Int
  latitude: Float
  longitude: Float
  mission: String
  mmsi: Int
  model: String
  name: String
  role: String
  speed_kn: Int
  status: String
  successful_landings: Int
  type: String
  weight_kg: Int
  weight_lbs: Int
  year_built: Int
}

type ShipsResult {
  data: [Ship]
  result: Result
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "accounts"
  """
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """
  fetch aggregated fields from the table: "accounts"
  """
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: Int!): accounts

  """
  fetch data from the table in a streaming manner : "accounts"
  """
  accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """
  fetch data from the table: "products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """fetch data from the table: "products" using primary key columns"""
  products_by_pk(id: Int!): products

  """
  fetch data from the table in a streaming manner : "products"
  """
  products_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [products_stream_cursor_input]!

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): [purchases!]!

  """An aggregate relationship"""
  purchases_aggregate(
    """distinct select on columns"""
    distinct_on: [purchases_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [purchases_order_by!]

    """filter the rows returned"""
    where: purchases_bool_exp
  ): purchases_aggregate!

  """fetch data from the table: "purchases" using primary key columns"""
  purchases_by_pk(id: bigint!): purchases

  """
  fetch data from the table in a streaming manner : "purchases"
  """
  purchases_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [purchases_stream_cursor_input]!

    """filter the rows returned"""
    where: purchases_bool_exp
  ): [purchases!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

type Volume {
  cubic_feet: Int
  cubic_meters: Int
}

